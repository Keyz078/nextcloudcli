#!/bin/bash

# ==== SESSION MANAGEMENT ====
SESSION_FILE="$HOME/.nextcloud_session"
GREEN="\033[0;32m"
RED="\033[0;31m"
YELLOW="\033[1;33m"
BLUE="\033[0;34m"
NC="\033[0m"

# Check if session file exists
# Function to ask yes/no with default Yes
ask_yes_no() {
    local prompt="$1"
    local answer
    while true; do
        read -p "$prompt (Y/n): " answer
        answer=${answer:-y}   # default to y if empty (Enter)
        case "$answer" in
            [Yy]) return 0 ;;   # Yes
            [Nn]) return 1 ;;   # No
            *) echo "Please enter Y or N." ;;
        esac
    done
}

if [[ -f "$SESSION_FILE" ]]; then
    source "$SESSION_FILE"

    if [[ -n "$CREDS" ]]; then
        # Decode username from creds
        DISPLAY_USERNAME=$(echo "$CREDS" | base64 --decode | cut -d: -f1)
        echo -e "${YELLOW}Saved login found: ${GREEN}${URL}${NC} as ${GREEN}${DISPLAY_USERNAME}${NC}"

        if ask_yes_no "Continue this session?"; then
            echo -e "${GREEN}Continuing session...${NC}"
        else
            echo -e "${YELLOW}Logging in...${NC}"
            rm -f "$SESSION_FILE"
            unset URL USERNAME PASSWORD CREDS
        fi
    else
        # If session file is not in the correct format
        rm -f "$SESSION_FILE"
        unset URL USERNAME PASSWORD CREDS
    fi
fi

# ==== LOGIN / SESSION VALIDATION ====
if [[ -z "$URL" ]]; then
    read -p "Enter Nextcloud URL with protocol (http/https): " URL
    read -p "Username: " USERNAME
    read -s -p "Password: " PASSWORD
    echo
    CREDS=$(echo -n "$USERNAME:$PASSWORD" | base64)
else
    # If session is continued, use existing CREDS
    USERNAME=$(echo "$CREDS" | base64 --decode | cut -d: -f1)
fi

BASE_URL="${URL}/remote.php/dav/files/${USERNAME}/"
STATUS=$(curl --connect-timeout 10 -k -H "Authorization: Basic $CREDS" -s -o /dev/null -w "%{http_code}" -X PROPFIND -H "Depth: 1" "${BASE_URL}")

if [[ "${STATUS}" == "207" || "${STATUS}" == "200" ]]; then
    echo -e "${GREEN}Login successful!${NC}"
    
    if [[ ! -f "$SESSION_FILE" ]]; then
        if ask_yes_no "Save session for next login?"; then
            echo -e "URL=\"$URL\"" > "$SESSION_FILE"
            echo "CREDS=\"$CREDS\"" >> "$SESSION_FILE"
            chmod 600 "$SESSION_FILE"
            echo -e "${GREEN}Session saved to $SESSION_FILE${NC}"
        fi
    fi
elif [[ "${STATUS}" == "401" ]]; then
    echo -e "${RED}Login failed: Incorrect username or password. Old session removed.${NC}"
    rm -f "$SESSION_FILE"
    exit 1
elif [[ "${STATUS}" == "404" || "${STATUS}" == "000" ]]; then
    echo -e "${RED}HTTP_CODE ${STATUS}: URL not found or server is unreachable. Old session removed.${NC}"
    rm -f "$SESSION_FILE"
    exit 1
fi

CURRENT_PATH="/"

trap "echo -e '\n${YELLOW}Cancelled by user.${NC}'; exit 1" SIGINT SIGTERM

# Path join function
join_path() {
    local base="$1"
    local part="$2"

    base=$(echo "$base" | sed 's/\/\//\//g')
    part=$(echo "$part" | sed 's/\/\//\//g')

    if [[ "$base" == "/" ]]; then
        combined_path="/$part"
    else
        combined_path="$base/$part"
    fi
    echo "$combined_path" | sed 's/\/$//'
}

# List directory and file contents
list_contents(){
    local path="$1"
    local encoded_path=$(echo "$path" | sed 's/ /%20/g')
    
    local response=$(curl -H "Authorization: Basic $CREDS" -s -k -X PROPFIND -H "Depth: 1" "$BASE_URL$encoded_path/" | grep -oP '(?<=<d:href>).*?(?=</d:href>)')

    local dir_list=()
    local file_list=()
    
    while read -r line; do
        local name=$(echo "$line" | sed "s|/remote.php/dav/files/$USERNAME$encoded_path/||g" \
                                     | sed "s|/remote.php/dav/files/$USERNAME/||g" \
                                     | sed 's/%20/ /g')
        if [[ "$name" == "" || "$name" == "." || "$name" == ".." || "$name" == "/" ]]; then
            continue
        fi

        if [[ "$line" =~ /$ ]]; then
            dir_list+=("$name")
        else
            file_list+=("$name")
        fi
    done <<< "$response"

    printf "%s\n" "${dir_list[@]}"
    echo "---"
    printf "%s\n" "${file_list[@]}"
}

# Main function for interactive mode
interactive_mode() {
    local mode="$1"
    local current_path="$CURRENT_PATH"

    while true; do
        echo -e "\n${YELLOW}${mode} mode - Current path: ${BLUE}$current_path${NC}"
        
        # Get content list
        IFS=$'\n' read -d '' -ra content_lines < <(list_contents "$current_path")
        local dir_list=()
        local file_list=()
        local separator_found=0

        for line in "${content_lines[@]}"; do
            if [[ "$line" == "---" ]]; then
                separator_found=1
                continue
            fi
            if [[ "$separator_found" -eq 0 ]]; then
                dir_list+=("$line")
            else
                file_list+=("$line")
            fi
        done
        
        local combined_list=("${dir_list[@]}" "${file_list[@]}")
        
        if [[ ${#combined_list[@]} -eq 0 && "$current_path" == "/" ]]; then
            echo -e "${RED}Directory is empty.${NC}"
            if [[ "$mode" == "upload" ]]; then
                 echo "You can upload files here."
            else
                 return 1
            fi
        fi

        # Show navigation options
        if [[ "$current_path" != "/" ]]; then
            echo -e "  cd .. ${YELLOW}Back to previous directory${NC}"
        fi
        echo "  0) Back to main menu"
        
        # Show contents in multiple columns
        output_list=()
        for i in "${!combined_list[@]}"; do
            local name="${combined_list[$i]}"
            local is_dir=false
            for dir in "${dir_list[@]}"; do
                if [[ "$name" == "$dir" ]]; then
                    is_dir=true
                    break
                fi
            done

            if $is_dir; then
                output_list+=("$(printf "%3d) [DIR]  %s" $((i+1)) "$name")")
            else
                output_list+=("$(printf "%3d) [FILE] %s" $((i+1)) "$name")")
            fi
       done

        width=$(tput cols)
        printf "%s\n" "${output_list[@]}" | column -c "${width}"
        
        # User input
        read -p "Enter choice (e.g.: cd <number>, <number>, or 0): " user_input
        local cmd=$(echo "$user_input" | awk '{print $1}')
        local num=$(echo "$user_input" | awk '{print $2}')
        
        case "$cmd" in
            cd)
                if [[ "$num" =~ ^[0-9]+$ ]] && (( num > 0 && num <= ${#dir_list[@]} )); then
                    local dir_name="${dir_list[$((num-1))]}"
                    current_path=$(join_path "$current_path" "$dir_name")
                    echo -e "${YELLOW}Entered directory: ${BLUE}$current_path${NC}"
                elif [[ "$num" == ".." ]]; then
                    if [[ "$current_path" != "/" ]]; then
                        current_path=$(dirname "$current_path")
                        [[ "$current_path" == "." ]] && current_path="/"
                    else
                        echo -e "${RED}Already at root directory.${NC}"
                    fi
                else
                    echo -e "${RED}Invalid command or number.${NC}"
                fi
                ;;
            0)
                return 0
                ;;
            *)
                if [[ "$user_input" =~ ^[0-9]+$ ]] && (( user_input > 0 && user_input <= ${#combined_list[@]} )); then
                    local selected_item="${combined_list[$((user_input-1))]}"
                    local is_dir=false
                    for dir in "${dir_list[@]}"; do
                        if [[ "$selected_item" == "$dir" ]]; then
                            is_dir=true
                            break
                        fi
                    done

                    if $is_dir; then
                         current_path=$(join_path "$current_path" "$selected_item")
                         echo -e "${YELLOW}Entered directory: ${BLUE}$current_path${NC}"
                    elif [[ "$mode" == "download" ]]; then
                        # Download file
                        local download_url=$(join_path "$current_path" "$selected_item")
                        # Escape space
                        download_url=$(echo "$download_url" | sed 's/ /%20/g')
                        echo -e "${YELLOW}Downloading '$selected_item' to current terminal location...${NC}"
                        curl --progress-bar -f -k -H "Authorization: Basic $CREDS" -o "$selected_item" "$BASE_URL$download_url" && \
                            echo -e "${GREEN}Download successful -> $selected_item${NC}" || \
                            echo -e "${RED}Download failed -> $selected_item${NC}"
                        return 0
                    fi
                elif [[ "$mode" == "upload" ]]; then
                    local local_file="$user_input"
                    if [[ -f "$local_file" ]]; then
                        local filename=$(basename -- "$local_file")
                        local upload_url=$(join_path "$current_path" "$filename")
                        # Escape space
                        upload_url=$(echo "$upload_url" | sed 's/ /%20/g')
                        echo -e "${YELLOW}Uploading '$filename' to '$current_path'...${NC}"
                        curl --progress-bar -f -k -H "Authorization: Basic $CREDS" -T "$local_file" "$BASE_URL$upload_url" && \
                            echo -e "${GREEN}Upload successful: $local_file${NC}" || \
                            echo -e "${RED}Upload failed: $local_file${NC}"
                        return 0
                    else
                        echo -e "${RED}Local file not found.${NC}"
                        # Removed return 0 so it won't go back to main menu
                    fi
                else
                    echo -e "${RED}Invalid choice.${NC}"
                fi
                ;;
        esac
    done
}

# Main menu loop
while true; do
    echo -e "\n${YELLOW}==== Nextcloud Menu ====${NC}"
    PS3="?> : "
    options=("Upload file" "Download file" "Exit")
    select opt in "${options[@]}"; do
        case $REPLY in
            1) interactive_mode "upload"; break ;;
            2) interactive_mode "download"; break ;;
            3) echo "Bye!"; exit 0 ;;
            *) echo -e "${RED}Invalid choice.${NC}"; break ;;
        esac
    done
done
